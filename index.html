<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Panorama Planner</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom styles for a better look and feel */
        body {
            font-family: 'Inter', sans-serif;
            overscroll-behavior: contain; /* Prevents pull-to-refresh on mobile */
        }
        /* Style for the range slider track */
        input[type="range"]::-webkit-slider-runnable-track {
            background: #374151; /* gray-700 */
        }
        input[type="range"]::-moz-range-track {
            background: #374151; /* gray-700 */
        }
        /* Style for the range slider thumb */
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            background: #3b82f6; /* blue-500 */
            cursor: pointer;
            height: 1.25rem;
            width: 1.25rem;
            border-radius: 9999px;
            margin-top: -6px; /* Center the thumb on the track */
        }
        input[type="range"]::-moz-range-thumb {
            background: #3b82f6; /* blue-500 */
            cursor: pointer;
            height: 1.25rem;
            width: 1.25rem;
            border-radius: 9999px;
        }
        .control-panel-grid {
            grid-template-columns: auto 1fr;
        }
        
        /* Fullscreen styles */
        body.fullscreen-active header,
        body.fullscreen-active #controls-panel {
            display: none;
        }
        
        body.fullscreen-active #camera-viewport {
            height: 100%;
        }

        body.fullscreen-active #fullscreen-btn .icon-expand {
            display: none;
        }

        body.fullscreen-active #fullscreen-btn .icon-compress {
            display: block;
        }
        
        body.fullscreen-active #fullscreen-capture-btn {
            display: flex;
        }

    </style>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap" rel="stylesheet">
</head>
<body id="body-container" class="bg-gray-900 text-white h-screen flex flex-col">

    <!-- Header -->
    <header class="bg-gray-800 p-3 text-center shadow-lg z-20 flex-shrink-0">
        <h1 class="text-xl font-bold">Panorama Planner</h1>
    </header>

    <!-- Main Content -->
    <main class="flex-grow flex flex-col relative min-h-0">
        <!-- Camera Viewport -->
        <div id="camera-viewport" class="relative w-full h-[35%] flex-shrink-0 bg-black flex items-center justify-center transition-all duration-300 ease-in-out">
            <video id="camera-feed" playsinline autoplay class="w-full h-full object-contain"></video>
            <canvas id="overlay-canvas" class="absolute top-0 left-0 w-full h-full"></canvas>
            <div id="permission-message" class="absolute inset-0 bg-gray-900 bg-opacity-80 p-4 text-center flex-col justify-center items-center hidden">
                <p class="text-lg">Waiting for camera permission...</p>
                <p class="text-sm text-gray-400 mt-2">Please allow camera access to use this app. If you denied it, you may need to reset permissions in your browser settings.</p>
            </div>
            <button id="fullscreen-btn" class="absolute top-2 right-2 bg-gray-900 bg-opacity-50 p-2 rounded-full z-10 text-white hover:bg-opacity-75 transition">
                <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="icon-expand h-6 w-6">
                    <path stroke-linecap="round" stroke-linejoin="round" d="M3.75 3.75v4.5m0-4.5h4.5m-4.5 0L9 9M20.25 20.25v-4.5m0 4.5h-4.5m4.5 0L15 15m-6 0L3.75 20.25m16.5-16.5L15 9" />
                </svg>
                <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="icon-compress h-6 w-6 hidden">
                    <path stroke-linecap="round" stroke-linejoin="round" d="M9 9V4.5M9 9H4.5M9 9L3.75 3.75M9 15v4.5M9 15H4.5M9 15l-5.25 5.25M15 9V4.5M15 9h4.5M15 9l5.25-5.25M15 15v4.5M15 15h4.5M15 15l5.25 5.25" />
                </svg>
            </button>
            <!-- Fullscreen Capture Button -->
            <button id="fullscreen-capture-btn" class="absolute bottom-6 bg-white w-16 h-16 rounded-full z-30 hidden items-center justify-center ring-4 ring-black ring-opacity-20">
                <div class="w-14 h-14 bg-white rounded-full border-4 border-gray-900"></div>
            </button>
        </div>

        <!-- Controls Panel -->
        <div id="controls-panel" class="bg-gray-800 p-4 space-y-4 z-10 flex-grow overflow-y-auto">
            
            <div class="space-y-4 border-b border-gray-700 pb-4">
                <h3 class="text-sm font-semibold text-gray-400 uppercase tracking-wider">Phone Preview Settings</h3>
                <!-- Phone Lens Selector -->
                <div class="grid control-panel-grid items-center gap-2">
                    <label for="camera-select" class="text-sm font-medium">Phone Lens</label>
                    <select id="camera-select" class="bg-gray-700 border border-gray-600 rounded-lg p-2 text-sm w-full"></select>
                </div>
                 <div class="grid control-panel-grid items-center gap-2">
                    <span class="text-sm font-medium text-gray-300">Detected FL</span>
                    <span id="detected-fl-info" class="text-sm text-gray-400 font-mono">N/A</span>
                </div>
                <!-- Phone Focal Length (Manual Override) -->
                <div class="grid control-panel-grid items-center gap-2">
                    <label for="phone-fl-select" class="text-sm font-medium">Phone FL (Manual)</label>
                    <select id="phone-fl-select" class="bg-gray-700 border border-gray-600 rounded-lg p-2 text-sm w-full">
                        <option value="auto" selected>Auto-Detect</option>
                        <option value="13">Ultrawide (~13mm)</option>
                        <option value="24">Wide (~24mm)</option>
                        <option value="50">Standard (~50mm)</option>
                        <option value="77">Telephoto (~77mm)</option>
                    </select>
                </div>
            </div>

            <div class="space-y-4 pt-2">
                 <h3 class="text-sm font-semibold text-gray-400 uppercase tracking-wider">Panorama Plan Settings</h3>
                <!-- Sensor Size -->
                <div class="grid control-panel-grid items-center gap-2">
                    <label for="sensor-size" class="text-sm font-medium">Sensor Size</label>
                    <select id="sensor-size" class="bg-gray-700 border border-gray-600 rounded-lg p-2 text-sm w-full">
                        <option value="phone">Phone (1/2.55")</option>
                        <option value="apsc">APS-C</option>
                        <option value="fullframe" selected>Full-Frame</option>
                        <option value="micro43">Micro 4/3</option>
                    </select>
                </div>

                <!-- Target Focal Length -->
                <div class="grid control-panel-grid items-center gap-2">
                    <label for="focal-length" class="text-sm font-medium">Target Focal Length</label>
                    <div class="flex items-center space-x-2">
                        <input type="range" id="focal-length" min="12" max="200" value="50" class="w-full h-2 rounded-lg appearance-none cursor-pointer">
                        <span id="focal-length-value" class="text-sm font-mono w-12 text-center">50mm</span>
                    </div>
                </div>

                <!-- Overlap -->
                <div class="grid control-panel-grid items-center gap-2">
                    <label for="overlap" class="text-sm font-medium">Overlap</label>
                    <div class="flex items-center space-x-2">
                        <input type="range" id="overlap" min="10" max="50" value="30" class="w-full h-2 rounded-lg appearance-none cursor-pointer">
                        <span id="overlap-value" class="text-sm font-mono w-12 text-center">30%</span>
                    </div>
                </div>

                <!-- Panel Count -->
                <div class="grid control-panel-grid items-center gap-2">
                    <label for="panel-count" class="text-sm font-medium">Panels</label>
                    <div class="flex items-center space-x-2">
                        <input type="range" id="panel-count" min="2" max="15" value="5" class="w-full h-2 rounded-lg appearance-none cursor-pointer">
                        <span id="panel-count-value" class="text-sm font-mono w-12 text-center">5</span>
                    </div>
                </div>

                <!-- Orientation -->
                <div class="grid control-panel-grid items-center gap-2">
                    <label class="text-sm font-medium">Orientation</label>
                    <div class="flex rounded-lg bg-gray-700 p-1">
                        <button id="orientation-landscape" class="w-full bg-blue-500 text-white rounded-md py-1 px-3 text-sm font-semibold">Landscape</button>
                        <button id="orientation-portrait" class="w-full text-gray-300 rounded-md py-1 px-3 text-sm">Portrait</button>
                    </div>
                </div>
            </div>

             <!-- Result Display -->
            <div class="bg-gray-900 rounded-lg p-3 text-center">
                <p class="text-sm text-gray-400 uppercase tracking-wider">Final Panorama FOV</p>
                <div class="flex justify-center items-baseline space-x-6 mt-1">
                    <div>
                        <span id="pano-fov-value" class="text-2xl font-bold text-blue-400">105.4째</span>
                        <span id="pano-fov-label" class="block text-xs text-gray-500">Horizontal</span>
                    </div>
                    <div>
                        <span id="pano-fov-vertical-value" class="text-2xl font-bold text-blue-400">27.0째</span>
                        <span id="pano-fov-vertical-label" class="block text-xs text-gray-500">Vertical</span>
                    </div>
                </div>
            </div>


            <!-- Action Button -->
            <button id="capture-button" class="w-full bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-4 rounded-lg transition-colors">
                Lock Plan & Capture Guide
            </button>
        </div>

        <!-- Guide Panel -->
        <div id="guide-panel" class="absolute inset-0 bg-gray-900 p-4 z-20 flex-col items-center justify-center text-center hidden">
            <h2 class="text-lg font-bold mb-2">Panorama Composition Guide</h2>
            <p class="text-sm text-gray-400 mb-4">This preview shows your first shot and the full area your panorama will cover.</p>
            <div id="guide-container" class="w-full overflow-auto p-2 bg-gray-950 rounded-lg flex justify-center items-center">
                <canvas id="guide-canvas" class="rounded-lg"></canvas>
            </div>
            <p id="guide-text" class="text-sm mt-4 text-gray-400">Pan right to capture the remaining panels, using the dashed lines as guides.</p>
            <button id="reset-button" class="mt-4 w-full max-w-xs bg-gray-600 hover:bg-gray-700 text-white font-bold py-3 px-4 rounded-lg transition-colors">
                Plan New Panorama
            </button>
        </div>

    </main>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // --- DOM Elements ---
            const bodyContainer = document.getElementById('body-container');
            const video = document.getElementById('camera-feed');
            const overlayCanvas = document.getElementById('overlay-canvas');
            const overlayCtx = overlayCanvas.getContext('2d');
            const permissionMessage = document.getElementById('permission-message');
            const fullscreenBtn = document.getElementById('fullscreen-btn');
            const fullscreenCaptureBtn = document.getElementById('fullscreen-capture-btn');

            const controlsPanel = document.getElementById('controls-panel');
            const cameraSelect = document.getElementById('camera-select');
            const detectedFLInfo = document.getElementById('detected-fl-info');
            const phoneFLSelect = document.getElementById('phone-fl-select');
            const sensorSelect = document.getElementById('sensor-size');
            const focalLengthSlider = document.getElementById('focal-length');
            const focalLengthValue = document.getElementById('focal-length-value');
            const overlapSlider = document.getElementById('overlap');
            const overlapValue = document.getElementById('overlap-value');
            const panelCountSlider = document.getElementById('panel-count');
            const panelCountValue = document.getElementById('panel-count-value');
            const landscapeBtn = document.getElementById('orientation-landscape');
            const portraitBtn = document.getElementById('orientation-portrait');
            const panoFovValue = document.getElementById('pano-fov-value');
            const panoFovLabel = document.getElementById('pano-fov-label');
            const panoFovVerticalValue = document.getElementById('pano-fov-vertical-value');
            const panoFovVerticalLabel = document.getElementById('pano-fov-vertical-label');
            
            const captureButton = document.getElementById('capture-button');
            const guidePanel = document.getElementById('guide-panel');
            const guideCanvas = document.getElementById('guide-canvas');
            const guideCtx = guideCanvas.getContext('2d');
            const guideContainer = document.getElementById('guide-container');
            const guideText = document.getElementById('guide-text');
            const resetButton = document.getElementById('reset-button');
            
            // --- State and Constants ---
            const SENSOR_SIZES = {
                fullframe: { width: 36, height: 24 },
                apsc: { width: 23.6, height: 15.7 },
                micro43: { width: 17.3, height: 13 },
                phone: { width: 6.66, height: 4.99 } // Approx 1/1.9" sensor
            };
            
            let state = {
                orientation: 'landscape', // 'landscape' or 'portrait'
                stream: null,
                lastOnScreenVerticalFov: 45, // Fallback
                lastOnScreenHorizontalFov: 75, // Fallback
                lastSingleFov: 0,
                lastSingleFovVertical: 0,
            };

            // --- Camera Initialization ---
            async function populateCameraList() {
                try {
                    // We need a dummy stream to request permission and get device labels.
                    await navigator.mediaDevices.getUserMedia({ video: true });
                    const devices = await navigator.mediaDevices.enumerateDevices();
                    const videoDevices = devices.filter(device => device.kind === 'videoinput');
                    
                    cameraSelect.innerHTML = '';
                    videoDevices.forEach((device, index) => {
                        const option = document.createElement('option');
                        option.value = device.deviceId;
                        option.text = device.label || `Camera ${index + 1}`;
                        cameraSelect.appendChild(option);
                    });
                    
                    if (videoDevices.length > 0) {
                        await startCamera(videoDevices[0].deviceId);
                    }
                } catch (err) {
                     console.error("Error enumerating devices:", err);
                     permissionMessage.style.display = 'flex';
                     permissionMessage.innerHTML = `<p class="text-lg text-red-500">Camera Access Denied</p><p class="text-sm text-gray-400 mt-2">Please enable camera permissions in your browser's settings and refresh the page.</p>`;
                }
            }
            
            async function startCamera(deviceId) {
                if (state.stream) {
                    state.stream.getTracks().forEach(track => track.stop());
                }
                
                permissionMessage.style.display = 'flex';
                const constraints = {
                    video: {
                        deviceId: deviceId ? { exact: deviceId } : undefined,
                        facingMode: 'environment',
                        width: { ideal: 1920 },
                        height: { ideal: 1080 }
                    }
                };
                
                try {
                    const stream = await navigator.mediaDevices.getUserMedia(constraints);
                    state.stream = stream;
                    video.srcObject = stream;
                    video.onloadedmetadata = () => {
                        permissionMessage.style.display = 'none';
                        video.play();
                        resizeCanvas();
                        updateDetectedFocalLengthInfo();
                        requestAnimationFrame(updateCalculationsAndDraw);
                    };
                } catch (err) {
                    console.error("Error accessing camera:", err);
                    permissionMessage.innerHTML = `<p class="text-lg text-red-500">Camera Access Denied</p><p class="text-sm text-gray-400 mt-2">Please enable camera permissions in your browser's settings and refresh the page.</p>`;
                }
            }
            
            function resizeCanvas() {
                const parentRect = video.parentElement.getBoundingClientRect();
                if (!video.videoWidth || !video.videoHeight) return;

                const videoAspectRatio = video.videoWidth / video.videoHeight;
                const parentAspectRatio = parentRect.width / parentRect.height;

                let canvasWidth, canvasHeight;

                if (videoAspectRatio > parentAspectRatio) {
                    canvasWidth = parentRect.width;
                    canvasHeight = parentRect.width / videoAspectRatio;
                } else {
                    canvasHeight = parentRect.height;
                    canvasWidth = parentRect.height * videoAspectRatio;
                }
                
                overlayCanvas.width = video.videoWidth;
                overlayCanvas.height = video.videoHeight;

                overlayCanvas.style.width = `${canvasWidth}px`;
                overlayCanvas.style.height = `${canvasHeight}px`;
                overlayCanvas.style.top = `${(parentRect.height - canvasHeight) / 2}px`;
                overlayCanvas.style.left = `${(parentRect.width - canvasWidth) / 2}px`;
            }

            window.addEventListener('resize', resizeCanvas);


            // --- Calculation Engine ---
            function calculateSingleFOV(sensorDimension, focalLength) {
                if (focalLength === 0) return 180;
                return 2 * Math.atan(sensorDimension / (2 * focalLength)) * (180 / Math.PI);
            }
            
            function updateDetectedFocalLengthInfo() {
                if (!state.stream) {
                    detectedFLInfo.textContent = 'N/A';
                    return;
                }
                const track = state.stream.getVideoTracks()[0];
                if (typeof track.getSettings !== 'function') {
                    detectedFLInfo.textContent = 'Unsupported';
                    return;
                }
                
                const settings = track.getSettings();
                if (settings.focalLength) {
                    const nativeFocalLength = settings.focalLength;
                    const phoneSensor = SENSOR_SIZES.phone;
                    const fullFrameSensor = SENSOR_SIZES.fullframe;

                    const phoneSensorDiagonal = Math.sqrt(phoneSensor.width**2 + phoneSensor.height**2);
                    const fullFrameDiagonal = Math.sqrt(fullFrameSensor.width**2 + fullFrameSensor.height**2);
                    
                    const cropFactor = fullFrameDiagonal / phoneSensorDiagonal;
                    const equivalentFocalLength = Math.round(nativeFocalLength * cropFactor);
                    
                    detectedFLInfo.textContent = `~${equivalentFocalLength}mm (35mm equiv.)`;
                } else {
                    detectedFLInfo.textContent = 'Not Found';
                }
            }

            function updateCalculationsAndDraw() {
                const sensor = SENSOR_SIZES[sensorSelect.value];
                const focalLength = parseInt(focalLengthSlider.value);
                const overlap = parseInt(overlapSlider.value) / 100;
                const panelCount = parseInt(panelCountSlider.value);

                focalLengthValue.textContent = `${focalLength}mm`;
                overlapValue.textContent = `${overlap * 100}%`;
                panelCountValue.textContent = panelCount;
                
                const horizontalSensorDim = sensor.width;
                const verticalSensorDim = sensor.height;

                const singleFovHorizontal = calculateSingleFOV(horizontalSensorDim, focalLength);
                const singleFovVertical = calculateSingleFOV(verticalSensorDim, focalLength);
                
                let longEdgeFov, shortEdgeFov;
                if (state.orientation === 'landscape') {
                    longEdgeFov = singleFovHorizontal;
                    shortEdgeFov = singleFovVertical;
                    panoFovLabel.textContent = 'Horizontal';
                    panoFovVerticalLabel.textContent = 'Vertical';
                } else {
                    longEdgeFov = singleFovVertical;
                    shortEdgeFov = singleFovHorizontal;
                    panoFovLabel.textContent = 'Vertical';
                    panoFovVerticalLabel.textContent = 'Horizontal';
                }

                state.lastSingleFov = longEdgeFov;
                state.lastSingleFovVertical = shortEdgeFov;

                let panoFov = (longEdgeFov * panelCount) - (longEdgeFov * overlap * (panelCount - 1));
                panoFovValue.textContent = `${panoFov.toFixed(1)}째`;
                panoFovVerticalValue.textContent = `${shortEdgeFov.toFixed(1)}째`;
                
                const videoTrack = state.stream ? state.stream.getVideoTracks()[0] : null;
                const videoSettings = videoTrack ? videoTrack.getSettings() : {};
                const manualPhoneFL = phoneFLSelect.value;
                
                let onScreenVerticalFov = 45; // Fallback
                let onScreenHorizontalFov = 75; // Fallback

                const videoIsPortrait = overlayCanvas.height > overlayCanvas.width && overlayCanvas.width > 0;

                if (manualPhoneFL !== 'auto') {
                    const fl = parseInt(manualPhoneFL);
                    const fullFrameSensor = SENSOR_SIZES.fullframe;

                    // We assume the equivalent focal length is for a 16:9 video aspect ratio,
                    // as this is standard for video. A 16:9 crop of a 36mm wide FF sensor is 36mm x 20.25mm.
                    const sensorWidthFor16x9 = fullFrameSensor.width; // 36mm
                    const sensorHeightFor16x9 = fullFrameSensor.width * (9/16); // 20.25mm

                    const landscapeHFOV = calculateSingleFOV(sensorWidthFor16x9, fl);
                    const landscapeVFOV = calculateSingleFOV(sensorHeightFor16x9, fl);

                    if (videoIsPortrait) {
                        onScreenHorizontalFov = landscapeVFOV;
                        onScreenVerticalFov = landscapeHFOV;
                    } else {
                        onScreenHorizontalFov = landscapeHFOV;
                        onScreenVerticalFov = landscapeVFOV;
                    }

                } else if (videoSettings.focalLength) {
                    const fl = videoSettings.focalLength;
                    const phoneSensor = SENSOR_SIZES.phone; // This is a 4:3 sensor
                    // Video is a 16:9 crop from the center of the 4:3 sensor.
                    const sensorWidthFor16x9 = phoneSensor.width; // 6.66mm
                    const sensorHeightFor16x9 = phoneSensor.width * (9/16); // 3.746mm

                    const landscapeHFOV = calculateSingleFOV(sensorWidthFor16x9, fl);
                    const landscapeVFOV = calculateSingleFOV(sensorHeightFor16x9, fl);

                    if (videoIsPortrait) {
                        onScreenHorizontalFov = landscapeVFOV;
                        onScreenVerticalFov = landscapeHFOV;
                    } else {
                        onScreenHorizontalFov = landscapeHFOV;
                        onScreenVerticalFov = landscapeVFOV;
                    }
                }
                
                state.lastOnScreenVerticalFov = onScreenVerticalFov;
                state.lastOnScreenHorizontalFov = onScreenHorizontalFov;

                drawOverlay(onScreenHorizontalFov, onScreenVerticalFov, panoFov, shortEdgeFov, panelCount, overlap);
                
                if (state.stream) {
                    requestAnimationFrame(updateCalculationsAndDraw);
                }
            }
            
            // --- Drawing Logic ---
            function drawOverlay(phoneHorizontalFov, phoneVerticalFov, panoTotalLongFov, panoShortFov, panelCount, overlap) {
                overlayCtx.clearRect(0, 0, overlayCanvas.width, overlayCanvas.height);
                
                const pixelsPerDegreeH = overlayCanvas.width / phoneHorizontalFov;
                const pixelsPerDegreeV = overlayCanvas.height / phoneVerticalFov;
                
                const panoWidth = panoShortFov * pixelsPerDegreeH;
                const panoHeight = panoTotalLongFov * pixelsPerDegreeV;
                
                const startX = (overlayCanvas.width - panoWidth) / 2;
                const startY = (overlayCanvas.height - panoHeight) / 2;
                
                overlayCtx.fillStyle = 'rgba(59, 130, 246, 0.2)';
                overlayCtx.strokeStyle = 'rgba(59, 130, 246, 0.8)';
                overlayCtx.lineWidth = 6;
                overlayCtx.fillRect(startX, startY, panoWidth, panoHeight);
                overlayCtx.strokeRect(startX, startY, panoWidth, panoHeight);

                // Draw divider lines inside the main overlay
                overlayCtx.strokeStyle = 'rgba(255, 255, 255, 0.6)';
                overlayCtx.lineWidth = 2;
                overlayCtx.setLineDash([15, 15]);

                const singlePanelLongFov = state.lastSingleFov;
                const panelAdvancePixels = (singlePanelLongFov * (1 - overlap)) * pixelsPerDegreeV;
                
                // The overlay is always drawn as a vertical box, so we draw horizontal lines to divide the height into panels.
                for (let i = 1; i < panelCount; i++) {
                    const lineY = startY + (i * panelAdvancePixels);
                     if (lineY > startY && lineY < startY + panoHeight) {
                         overlayCtx.beginPath();
                         overlayCtx.moveTo(startX, lineY);
                         overlayCtx.lineTo(startX + panoWidth, lineY);
                         overlayCtx.stroke();
                     }
                }
                overlayCtx.setLineDash([]);
            }

            // --- Capture Logic ---
            function captureGuide() {
                if (bodyContainer.classList.contains('fullscreen-active')) {
                    bodyContainer.classList.remove('fullscreen-active');
                }
                controlsPanel.classList.add('hidden');
                guidePanel.style.display = 'flex';

                const tempCanvas = document.createElement('canvas');
                tempCanvas.width = video.videoWidth;
                tempCanvas.height = video.videoHeight;
                const tempCtx = tempCanvas.getContext('2d');
                tempCtx.drawImage(video, 0, 0, tempCanvas.width, tempCanvas.height);

                const overlapPercent = parseInt(overlapSlider.value) / 100;
                const panelCount = parseInt(panelCountSlider.value);
                
                const pixelsPerDegreeH = tempCanvas.width / state.lastOnScreenHorizontalFov;
                const pixelsPerDegreeV = tempCanvas.height / state.lastOnScreenVerticalFov;
                
                const plannedPanelWidthDeg = state.orientation === 'landscape' ? state.lastSingleFov : state.lastSingleFovVertical;
                const plannedPanelHeightDeg = state.orientation === 'landscape' ? state.lastSingleFovVertical : state.lastSingleFov;

                const panelWidthPx = plannedPanelWidthDeg * pixelsPerDegreeH;
                const panelHeightPx = plannedPanelHeightDeg * pixelsPerDegreeV;


                if (state.orientation === 'landscape') {
                    const panelAdvance = panelWidthPx * (1 - overlapPercent);
                    const totalGuideWidth = panelWidthPx + (panelAdvance * (panelCount - 1));
                    
                    guideCanvas.width = totalGuideWidth;
                    guideCanvas.height = panelHeightPx;
                    guideContainer.style.overflowX = 'auto';
                    guideContainer.style.overflowY = 'hidden';
                    guideText.textContent = "Pan right to capture the remaining panels, using the dashed lines as guides.";
                    
                    // Crop the first panel from the center of the captured video frame
                    const cropX = (tempCanvas.width - panelWidthPx) / 2;
                    const cropY = (tempCanvas.height - panelHeightPx) / 2;
                    guideCtx.drawImage(tempCanvas, cropX, cropY, panelWidthPx, panelHeightPx, 0, 0, panelWidthPx, panelHeightPx);

                    // Draw overlay for remaining panels
                    guideCtx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                    guideCtx.fillRect(panelWidthPx, 0, totalGuideWidth - panelWidthPx, panelHeightPx);
                    
                    // Draw overall frame
                    guideCtx.strokeStyle = '#3b82f6';
                    guideCtx.lineWidth = 8;
                    guideCtx.strokeRect(0, 0, totalGuideWidth, panelHeightPx);
                    
                    // Draw divider lines
                    guideCtx.strokeStyle = 'rgba(255, 255, 255, 0.7)';
                    guideCtx.lineWidth = 3;
                    guideCtx.setLineDash([20, 15]);
                    for (let i = 1; i < panelCount; i++) {
                        const lineX = i * panelAdvance;
                        guideCtx.beginPath();
                        guideCtx.moveTo(lineX, 0);
                        guideCtx.lineTo(lineX, panelHeightPx);
                        guideCtx.stroke();
                    }
                } else { // Portrait
                    const panelAdvance = panelHeightPx * (1 - overlapPercent);
                    const totalGuideHeight = panelHeightPx + (panelAdvance * (panelCount - 1));

                    guideCanvas.width = panelWidthPx;
                    guideCanvas.height = totalGuideHeight;
                    guideContainer.style.overflowY = 'auto';
                    guideContainer.style.overflowX = 'hidden';
                    guideText.textContent = "Pan up to capture the remaining panels, using the dashed lines as guides.";

                    // Crop the first panel from the center of the captured video frame
                    const cropX = (tempCanvas.width - panelWidthPx) / 2;
                    const cropY = (tempCanvas.height - panelHeightPx) / 2;
                    guideCtx.drawImage(tempCanvas, cropX, cropY, panelWidthPx, panelHeightPx, 0, 0, panelWidthPx, panelHeightPx);

                    // Draw overlay for remaining panels
                    guideCtx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                    guideCtx.fillRect(0, panelHeightPx, panelWidthPx, totalGuideHeight - panelHeightPx);

                    // Draw overall frame
                    guideCtx.strokeStyle = '#3b82f6';
                    guideCtx.lineWidth = 8;
                    guideCtx.strokeRect(0, 0, panelWidthPx, totalGuideHeight);
                    
                    // Draw divider lines
                    guideCtx.strokeStyle = 'rgba(255, 255, 255, 0.7)';
                    guideCtx.lineWidth = 3;
                    guideCtx.setLineDash([20, 15]);
                    for (let i = 1; i < panelCount; i++) {
                        const lineY = i * panelAdvance;
                        guideCtx.beginPath();
                        guideCtx.moveTo(0, lineY);
                        guideCtx.lineTo(panelWidthPx, lineY);
                        guideCtx.stroke();
                    }
                }
                guideCtx.setLineDash([]);
            }

            // --- Event Listeners ---
            [focalLengthSlider, overlapSlider, panelCountSlider, sensorSelect, phoneFLSelect].forEach(el => {
                el.addEventListener('input', () => {});
            });

            cameraSelect.addEventListener('change', (e) => startCamera(e.target.value));

            landscapeBtn.addEventListener('click', () => {
                state.orientation = 'landscape';
                landscapeBtn.classList.add('bg-blue-500', 'text-white');
                landscapeBtn.classList.remove('text-gray-300');
                portraitBtn.classList.remove('bg-blue-500', 'text-white');
                portraitBtn.classList.add('text-gray-300');
            });
            
            portraitBtn.addEventListener('click', () => {
                state.orientation = 'portrait';
                portraitBtn.classList.add('bg-blue-500', 'text-white');
                portraitBtn.classList.remove('text-gray-300');
                landscapeBtn.classList.remove('bg-blue-500', 'text-white');
                landscapeBtn.classList.add('text-gray-300');
            });

            fullscreenBtn.addEventListener('click', () => {
                bodyContainer.classList.toggle('fullscreen-active');
                setTimeout(resizeCanvas, 300);
            });

            captureButton.addEventListener('click', captureGuide);
            fullscreenCaptureBtn.addEventListener('click', captureGuide);
            
            resetButton.addEventListener('click', () => {
                guidePanel.style.display = 'none';
                controlsPanel.classList.remove('hidden');
            });
            
            // --- Start the app ---
            populateCameraList();
        });
    </script>
</body>
</html>


