<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Panorama Planner</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom styles for a better look and feel */
        body {
            font-family: 'Inter', sans-serif;
            overscroll-behavior: contain; /* Prevents pull-to-refresh on mobile */
        }
        /* Style for the range slider track */
        input[type="range"]::-webkit-slider-runnable-track {
            background: #374151; /* gray-700 */
        }
        input[type="range"]::-moz-range-track {
            background: #374151; /* gray-700 */
        }
        /* Style for the range slider thumb */
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            background: #3b82f6; /* blue-500 */
            cursor: pointer;
            height: 1.25rem;
            width: 1.25rem;
            border-radius: 9999px;
            margin-top: -6px; /* Center the thumb on the track */
        }
        input[type="range"]::-moz-range-thumb {
            background: #3b82f6; /* blue-500 */
            cursor: pointer;
            height: 1.25rem;
            width: 1.25rem;
            border-radius: 9999px;
        }
        .control-panel-grid {
            grid-template-columns: auto 1fr;
        }
        
        /* Fullscreen styles */
        body.fullscreen-active header,
        body.fullscreen-active #controls-panel {
            display: none;
        }
        
        body.fullscreen-active #camera-viewport {
            height: 100%;
        }

        body.fullscreen-active .icon-expand {
            display: none;
        }

        body.fullscreen-active .icon-compress {
            display: block;
        }

    </style>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap" rel="stylesheet">
</head>
<body id="body-container" class="bg-gray-900 text-white h-screen flex flex-col">

    <!-- Header -->
    <header class="bg-gray-800 p-3 text-center shadow-lg z-20 flex-shrink-0">
        <h1 class="text-xl font-bold">Panorama Planner</h1>
    </header>

    <!-- Main Content -->
    <main class="flex-grow flex flex-col relative min-h-0">
        <!-- Camera Viewport -->
        <div id="camera-viewport" class="relative w-full h-[35%] flex-shrink-0 bg-black flex items-center justify-center transition-all duration-300 ease-in-out">
            <video id="camera-feed" playsinline autoplay class="w-full h-full object-contain"></video>
            <canvas id="overlay-canvas" class="absolute top-0 left-0 w-full h-full"></canvas>
            <div id="permission-message" class="absolute inset-0 bg-gray-900 bg-opacity-80 p-4 text-center flex-col justify-center items-center hidden">
                <p class="text-lg">Waiting for camera permission...</p>
                <p class="text-sm text-gray-400 mt-2">Please allow camera access to use this app. If you denied it, you may need to reset permissions in your browser settings.</p>
            </div>
            <button id="fullscreen-btn" class="absolute top-2 right-2 bg-gray-900 bg-opacity-50 p-2 rounded-full z-10 text-white hover:bg-opacity-75 transition">
                <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="icon-expand h-6 w-6">
                    <path stroke-linecap="round" stroke-linejoin="round" d="M3.75 3.75v4.5m0-4.5h4.5m-4.5 0L9 9M20.25 20.25v-4.5m0 4.5h-4.5m4.5 0L15 15m-6 0L3.75 20.25m16.5-16.5L15 9" />
                </svg>
                <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="icon-compress h-6 w-6 hidden">
                    <path stroke-linecap="round" stroke-linejoin="round" d="M9 9V4.5M9 9H4.5M9 9L3.75 3.75M9 15v4.5M9 15H4.5M9 15l-5.25 5.25M15 9V4.5M15 9h4.5M15 9l5.25-5.25M15 15v4.5M15 15h4.5M15 15l5.25 5.25" />
                </svg>
            </button>
        </div>

        <!-- Controls Panel -->
        <div id="controls-panel" class="bg-gray-800 p-4 space-y-4 z-10 flex-grow overflow-y-auto">
            
            <div class="space-y-4 border-b border-gray-700 pb-4">
                <h3 class="text-sm font-semibold text-gray-400 uppercase tracking-wider">Phone Preview Settings</h3>
                <!-- Phone Lens Selector -->
                <div class="grid control-panel-grid items-center gap-2">
                    <label for="camera-select" class="text-sm font-medium">Phone Lens</label>
                    <select id="camera-select" class="bg-gray-700 border border-gray-600 rounded-lg p-2 text-sm w-full"></select>
                </div>
                 <div class="grid control-panel-grid items-center gap-2">
                    <span class="text-sm font-medium text-gray-300">Detected FL</span>
                    <span id="detected-fl-info" class="text-sm text-gray-400 font-mono">N/A</span>
                </div>
                <!-- Phone Focal Length (Manual Override) -->
                <div class="grid control-panel-grid items-center gap-2">
                    <label for="phone-fl-select" class="text-sm font-medium">Phone FL (Manual)</label>
                    <select id="phone-fl-select" class="bg-gray-700 border border-gray-600 rounded-lg p-2 text-sm w-full">
                        <option value="auto" selected>Auto-Detect</option>
                        <option value="13">Ultrawide (~13mm)</option>
                        <option value="24">Wide (~24mm)</option>
                        <option value="50">Standard (~50mm)</option>
                        <option value="77">Telephoto (~77mm)</option>
                    </select>
                </div>
            </div>

            <div class="space-y-4 pt-2">
                 <h3 class="text-sm font-semibold text-gray-400 uppercase tracking-wider">Panorama Plan Settings</h3>
                <!-- Sensor Size -->
                <div class="grid control-panel-grid items-center gap-2">
                    <label for="sensor-size" class="text-sm font-medium">Sensor Size</label>
                    <select id="sensor-size" class="bg-gray-700 border border-gray-600 rounded-lg p-2 text-sm w-full">
                        <option value="phone">Phone (1/2.55")</option>
                        <option value="apsc">APS-C</option>
                        <option value="fullframe" selected>Full-Frame</option>
                        <option value="micro43">Micro 4/3</option>
                    </select>
                </div>

                <!-- Target Focal Length -->
                <div class="grid control-panel-grid items-center gap-2">
                    <label for="focal-length" class="text-sm font-medium">Target Focal Length</label>
                    <div class="flex items-center space-x-2">
                        <input type="range" id="focal-length" min="12" max="200" value="50" class="w-full h-2 rounded-lg appearance-none cursor-pointer">
                        <span id="focal-length-value" class="text-sm font-mono w-12 text-center">50mm</span>
                    </div>
                </div>

                <!-- Overlap -->
                <div class="grid control-panel-grid items-center gap-2">
                    <label for="overlap" class="text-sm font-medium">Overlap</label>
                    <div class="flex items-center space-x-2">
                        <input type="range" id="overlap" min="10" max="50" value="30" class="w-full h-2 rounded-lg appearance-none cursor-pointer">
                        <span id="overlap-value" class="text-sm font-mono w-12 text-center">30%</span>
                    </div>
                </div>

                <!-- Panel Count -->
                <div class="grid control-panel-grid items-center gap-2">
                    <label for="panel-count" class="text-sm font-medium">Panels</label>
                    <div class="flex items-center space-x-2">
                        <input type="range" id="panel-count" min="2" max="15" value="5" class="w-full h-2 rounded-lg appearance-none cursor-pointer">
                        <span id="panel-count-value" class="text-sm font-mono w-12 text-center">5</span>
                    </div>
                </div>

                <!-- Orientation -->
                <div class="grid control-panel-grid items-center gap-2">
                    <label class="text-sm font-medium">Orientation</label>
                    <div class="flex rounded-lg bg-gray-700 p-1">
                        <button id="orientation-landscape" class="w-full bg-blue-500 text-white rounded-md py-1 px-3 text-sm font-semibold">Landscape</button>
                        <button id="orientation-portrait" class="w-full text-gray-300 rounded-md py-1 px-3 text-sm">Portrait</button>
                    </div>
                </div>
            </div>

             <!-- Result Display -->
            <div class="bg-gray-900 rounded-lg p-3 text-center">
                <p class="text-sm text-gray-400 uppercase tracking-wider">Final Panorama FOV</p>
                <div class="flex justify-center items-baseline space-x-6 mt-1">
                    <div>
                        <span id="pano-fov-value" class="text-2xl font-bold text-blue-400">105.4°</span>
                        <span class="block text-xs text-gray-500">Horizontal</span>
                    </div>
                    <div>
                        <span id="pano-fov-vertical-value" class="text-2xl font-bold text-blue-400">27.0°</span>
                        <span class="block text-xs text-gray-500">Vertical</span>
                    </div>
                </div>
            </div>


            <!-- Action Button -->
            <button id="capture-button" class="w-full bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-4 rounded-lg transition-colors">
                Lock Plan & Capture Guide
            </button>
        </div>

        <!-- Guide Panel -->
        <div id="guide-panel" class="absolute inset-0 bg-gray-900 p-4 z-20 flex-col items-center justify-center text-center hidden">
            <h2 class="text-lg font-bold mb-2">Panorama Composition Guide</h2>
            <p class="text-sm text-gray-400 mb-4">This preview shows your first shot and the full area your panorama will cover.</p>
            <div class="w-full overflow-x-auto p-2 bg-gray-950 rounded-lg flex justify-center items-center">
                <canvas id="guide-canvas" class="rounded-lg"></canvas>
            </div>
            <p class="text-sm mt-4 text-gray-400">Pan right to capture the remaining panels, using the dashed lines as guides.</p>
            <button id="reset-button" class="mt-4 w-full max-w-xs bg-gray-600 hover:bg-gray-700 text-white font-bold py-3 px-4 rounded-lg transition-colors">
                Plan New Panorama
            </button>
        </div>

    </main>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // --- DOM Elements ---
            const bodyContainer = document.getElementById('body-container');
            const video = document.getElementById('camera-feed');
            const overlayCanvas = document.getElementById('overlay-canvas');
            const overlayCtx = overlayCanvas.getContext('2d');
            const permissionMessage = document.getElementById('permission-message');
            const fullscreenBtn = document.getElementById('fullscreen-btn');
            const iconExpand = fullscreenBtn.querySelector('.icon-expand');
            const iconCompress = fullscreenBtn.querySelector('.icon-compress');

            const controlsPanel = document.getElementById('controls-panel');
            const cameraSelect = document.getElementById('camera-select');
            const detectedFLInfo = document.getElementById('detected-fl-info');
            const phoneFLSelect = document.getElementById('phone-fl-select');
            const sensorSelect = document.getElementById('sensor-size');
            const focalLengthSlider = document.getElementById('focal-length');
            const focalLengthValue = document.getElementById('focal-length-value');
            const overlapSlider = document.getElementById('overlap');
            const overlapValue = document.getElementById('overlap-value');
            const panelCountSlider = document.getElementById('panel-count');
            const panelCountValue = document.getElementById('panel-count-value');
            const landscapeBtn = document.getElementById('orientation-landscape');
            const portraitBtn = document.getElementById('orientation-portrait');
            const panoFovValue = document.getElementById('pano-fov-value');
            const panoFovVerticalValue = document.getElementById('pano-fov-vertical-value');
            
            const captureButton = document.getElementById('capture-button');
            const guidePanel = document.getElementById('guide-panel');
            const guideCanvas = document.getElementById('guide-canvas');
            const guideCtx = guideCanvas.getContext('2d');
            const resetButton = document.getElementById('reset-button');
            
            // --- State and Constants ---
            const SENSOR_SIZES = {
                fullframe: { width: 36, height: 24 },
                apsc: { width: 23.6, height: 15.7 },
                micro43: { width: 17.3, height: 13 },
                phone: { width: 5.6, height: 4.2 } // Approx 1/2.55" sensor
            };
            
            let state = {
                orientation: 'landscape', // 'landscape' or 'portrait'
                stream: null,
                lastOnScreenFov: 75,
                lastSingleFov: 0,
                lastSingleFovVertical: 0,
            };

            // --- Camera Initialization ---
            async function populateCameraList() {
                try {
                    const devices = await navigator.mediaDevices.enumerateDevices();
                    const videoDevices = devices.filter(device => device.kind === 'videoinput');
                    
                    cameraSelect.innerHTML = '';
                    videoDevices.forEach((device, index) => {
                        const option = document.createElement('option');
                        option.value = device.deviceId;
                        // Try to create a user-friendly label
                        option.text = device.label || `Camera ${index + 1}`;
                        cameraSelect.appendChild(option);
                    });
                    
                    if (videoDevices.length > 0) {
                        await startCamera(videoDevices[0].deviceId);
                    }
                } catch (err) {
                     console.error("Error enumerating devices:", err);
                }
            }
            
            async function startCamera(deviceId) {
                // Stop any existing stream
                if (state.stream) {
                    state.stream.getTracks().forEach(track => track.stop());
                }
                
                permissionMessage.style.display = 'flex';
                const constraints = {
                    video: {
                        deviceId: deviceId ? { exact: deviceId } : undefined,
                        facingMode: 'environment',
                        width: { ideal: 1920 },
                        height: { ideal: 1080 }
                    }
                };
                
                try {
                    const stream = await navigator.mediaDevices.getUserMedia(constraints);
                    state.stream = stream;
                    video.srcObject = stream;
                    video.onloadedmetadata = () => {
                        permissionMessage.style.display = 'none';
                        video.play();
                        resizeCanvas();
                        updateDetectedFocalLengthInfo();
                        // Restart animation loop if it was stopped
                        requestAnimationFrame(updateCalculationsAndDraw);
                    };
                } catch (err) {
                    console.error("Error accessing camera:", err);
                    permissionMessage.innerHTML = `<p class="text-lg text-red-500">Camera Access Denied</p><p class="text-sm text-gray-400 mt-2">Please enable camera permissions in your browser's settings and refresh the page.</p>`;
                }
            }
            
            function resizeCanvas() {
                const parentRect = video.parentElement.getBoundingClientRect();
                const videoAspectRatio = video.videoWidth / video.videoHeight;
                const parentAspectRatio = parentRect.width / parentRect.height;

                let canvasWidth, canvasHeight;

                if (videoAspectRatio > parentAspectRatio) {
                    canvasWidth = parentRect.width;
                    canvasHeight = parentRect.width / videoAspectRatio;
                } else {
                    canvasHeight = parentRect.height;
                    canvasWidth = parentRect.height * videoAspectRatio;
                }
                
                overlayCanvas.width = video.videoWidth;
                overlayCanvas.height = video.videoHeight;

                overlayCanvas.style.width = `${canvasWidth}px`;
                overlayCanvas.style.height = `${canvasHeight}px`;
                overlayCanvas.style.top = `${(parentRect.height - canvasHeight) / 2}px`;
                overlayCanvas.style.left = `${(parentRect.width - canvasWidth) / 2}px`;
            }

            window.addEventListener('resize', resizeCanvas);


            // --- Calculation Engine ---
            function calculateSingleFOV(sensorDimension, focalLength) {
                return 2 * Math.atan(sensorDimension / (2 * focalLength)) * (180 / Math.PI);
            }
            
            function updateDetectedFocalLengthInfo() {
                if (!state.stream) {
                    detectedFLInfo.textContent = 'N/A';
                    return;
                }
                const track = state.stream.getVideoTracks()[0];
                if (typeof track.getSettings !== 'function') {
                    detectedFLInfo.textContent = 'Unsupported';
                    return;
                }
                
                const settings = track.getSettings();
                if (settings.focalLength) {
                    const nativeFocalLength = settings.focalLength;
                    // For phone camera focal length, we'll calculate its 35mm equivalent based on the "Phone" sensor size preset
                    const phoneSensor = SENSOR_SIZES.phone;
                    const fullFrameSensor = SENSOR_SIZES.fullframe;

                    const phoneSensorDiagonal = Math.sqrt(phoneSensor.width**2 + phoneSensor.height**2);
                    const fullFrameDiagonal = Math.sqrt(fullFrameSensor.width**2 + fullFrameSensor.height**2);
                    
                    const cropFactor = fullFrameDiagonal / phoneSensorDiagonal;
                    const equivalentFocalLength = Math.round(nativeFocalLength * cropFactor);
                    
                    detectedFLInfo.textContent = `~${equivalentFocalLength}mm (35mm equiv.)`;
                } else {
                    detectedFLInfo.textContent = 'Not Found';
                }
            }

            function updateCalculationsAndDraw() {
                // Read values from controls for the PLAN
                const sensor = SENSOR_SIZES[sensorSelect.value];
                const focalLength = parseInt(focalLengthSlider.value);
                const overlap = parseInt(overlapSlider.value) / 100;
                const panelCount = parseInt(panelCountSlider.value);

                // Update UI text values
                focalLengthValue.textContent = `${focalLength}mm`;
                overlapValue.textContent = `${overlap * 100}%`;
                panelCountValue.textContent = panelCount;
                
                // Perform calculations for the PLAN
                const horizontalSensorDim = state.orientation === 'landscape' ? sensor.width : sensor.height;
                const verticalSensorDim = state.orientation === 'landscape' ? sensor.height : sensor.width;

                const singleFov = calculateSingleFOV(horizontalSensorDim, focalLength);
                const singleFovVertical = calculateSingleFOV(verticalSensorDim, focalLength);
                
                state.lastSingleFov = singleFov; // Store for capture guide
                state.lastSingleFovVertical = singleFovVertical;

                let panoFov = (singleFov * panelCount) - (singleFov * overlap * (panelCount - 1));
                panoFovValue.textContent = `${panoFov.toFixed(1)}°`;
                panoFovVerticalValue.textContent = `${singleFovVertical.toFixed(1)}°`;
                
                // --- Now calculate the FOV for the LIVE PREVIEW to draw the overlay correctly ---
                const videoTrack = state.stream ? state.stream.getVideoTracks()[0] : null;
                const videoSettings = videoTrack ? videoTrack.getSettings() : {};
                const manualPhoneFL = phoneFLSelect.value;

                let onScreenFov = 75; // Default fallback FOV

                if (manualPhoneFL !== 'auto') {
                    // User has selected a manual override (value is 35mm equivalent)
                    const fullFrameSensor = SENSOR_SIZES.fullframe;
                    const videoIsPortrait = video.videoHeight > video.videoWidth;
                    const previewSensorDimForCalc = videoIsPortrait ? fullFrameSensor.height : fullFrameSensor.width;
                    onScreenFov = calculateSingleFOV(previewSensorDimForCalc, parseInt(manualPhoneFL));

                } else if (videoSettings.focalLength) {
                    // Auto-detect is selected and focal length is available from the API
                    const phoneSensor = SENSOR_SIZES.phone;
                    const videoIsPortrait = video.videoHeight > video.videoWidth;
                    const previewSensorDim = videoIsPortrait ? phoneSensor.height : phoneSensor.width;
                    onScreenFov = calculateSingleFOV(previewSensorDim, videoSettings.focalLength);
                }
                // Else, it will use the default fallback FOV of 75 degrees.
                state.lastOnScreenFov = onScreenFov; // Store for capture guide

                // Draw the overlay
                drawOverlay(onScreenFov, panoFov, singleFovVertical, panelCount, overlap);
                
                if (state.stream) {
                   requestAnimationFrame(updateCalculationsAndDraw);
                }
            }
            
            // --- Drawing Logic ---
            function drawOverlay(phoneFov, panoFov, panoFovVertical, panelCount, overlap) {
                overlayCtx.clearRect(0, 0, overlayCanvas.width, overlayCanvas.height);
                
                const pixelsPerDegree = overlayCanvas.width / phoneFov;
                const panoWidth = panoFov * pixelsPerDegree;
                const panoHeight = panoFovVertical * pixelsPerDegree;
                const panelWidthDegrees = (panoFov + (panoFovVertical * overlap * (panelCount - 1))) / panelCount; // This is an approximation
                const panelAdvanceWidth = panelWidthDegrees * (1 - overlap) * pixelsPerDegree;

                const startX = (overlayCanvas.width - panoWidth) / 2;
                const startY = (overlayCanvas.height - panoHeight) / 2;
                
                overlayCtx.fillStyle = 'rgba(59, 130, 246, 0.2)';
                overlayCtx.strokeStyle = 'rgba(59, 130, 246, 0.8)';
                overlayCtx.lineWidth = 6;
                overlayCtx.fillRect(startX, startY, panoWidth, panoHeight);
                overlayCtx.strokeRect(startX, startY, panoWidth, panoHeight);
                
                overlayCtx.strokeStyle = 'rgba(255, 255, 255, 0.6)';
                overlayCtx.lineWidth = 2;
                overlayCtx.setLineDash([15, 15]);

                for (let i = 1; i < panelCount; i++) {
                    const lineX = startX + (i * panelAdvanceWidth);
                     if (lineX > startX && lineX < startX + panoWidth) {
                        overlayCtx.beginPath();
                        overlayCtx.moveTo(lineX, startY);
                        overlayCtx.lineTo(lineX, startY + panoHeight);
                        overlayCtx.stroke();
                    }
                }
                overlayCtx.setLineDash([]);
            }

            // --- Capture Logic ---
            function captureGuide() {
                controlsPanel.classList.add('hidden');
                guidePanel.style.display = 'flex';

                // 1. Capture the current full video frame
                const tempCanvas = document.createElement('canvas');
                tempCanvas.width = video.videoWidth;
                tempCanvas.height = video.videoHeight;
                const tempCtx = tempCanvas.getContext('2d');
                tempCtx.drawImage(video, 0, 0, tempCanvas.width, tempCanvas.height);

                // 2. Get panorama settings
                const overlapPercent = parseInt(overlapSlider.value) / 100;
                const panelCount = parseInt(panelCountSlider.value);

                // 3. Calculate dimensions based on FOV for accurate scaling
                const pixelsPerDegree = tempCanvas.width / state.lastOnScreenFov;
                const plannedPanelWidth = state.lastSingleFov * pixelsPerDegree;
                const plannedPanelHeight = state.lastSingleFovVertical * pixelsPerDegree;

                const panelAdvanceWidth = plannedPanelWidth * (1 - overlapPercent);
                const totalGuideWidth = plannedPanelWidth + (panelAdvanceWidth * (panelCount - 1));

                // 4. Set final guide canvas dimensions
                guideCanvas.width = totalGuideWidth;
                guideCanvas.height = plannedPanelHeight;
                
                // 5. Draw the entire captured video frame into the first panel's area.
                // This maintains the visual context, even if stretched, within a correctly-proportioned frame.
                guideCtx.drawImage(
                    tempCanvas,       // source canvas
                    0, 0,             // destination x, y
                    plannedPanelWidth, plannedPanelHeight  // destination width, height
                );

                // 6. Draw a semi-transparent overlay for the un-captured area
                guideCtx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                guideCtx.fillRect(plannedPanelWidth, 0, totalGuideWidth - plannedPanelWidth, plannedPanelHeight);
                
                // 7. Draw the overall panorama frame
                guideCtx.strokeStyle = '#3b82f6'; // blue-500
                guideCtx.lineWidth = 8;
                guideCtx.strokeRect(0, 0, totalGuideWidth, plannedPanelHeight);

                // 8. Draw panel divider lines
                guideCtx.strokeStyle = 'rgba(255, 255, 255, 0.7)';
                guideCtx.lineWidth = 3;
                guideCtx.setLineDash([20, 15]);

                for (let i = 1; i < panelCount; i++) {
                    const lineX = i * panelAdvanceWidth;
                    guideCtx.beginPath();
                    guideCtx.moveTo(lineX, 0);
                    guideCtx.lineTo(lineX, plannedPanelHeight);
                    guideCtx.stroke();
                }
                guideCtx.setLineDash([]);
            }

            // --- Event Listeners ---
            [focalLengthSlider, overlapSlider, panelCountSlider, sensorSelect, phoneFLSelect].forEach(el => {
                el.addEventListener('input', () => { /* Trigger animation frame */ });
            });

            cameraSelect.addEventListener('change', (e) => {
                startCamera(e.target.value);
            });

            landscapeBtn.addEventListener('click', () => {
                state.orientation = 'landscape';
                landscapeBtn.classList.add('bg-blue-500', 'text-white');
                landscapeBtn.classList.remove('text-gray-300');
                portraitBtn.classList.remove('bg-blue-500', 'text-white');
                portraitBtn.classList.add('text-gray-300');
            });
            
            portraitBtn.addEventListener('click', () => {
                state.orientation = 'portrait';
                portraitBtn.classList.add('bg-blue-500', 'text-white');
                portraitBtn.classList.remove('text-gray-300');
                landscapeBtn.classList.remove('bg-blue-500', 'text-white');
                landscapeBtn.classList.add('text-gray-300');
            });

            fullscreenBtn.addEventListener('click', () => {
                bodyContainer.classList.toggle('fullscreen-active');
                iconExpand.classList.toggle('hidden');
                iconCompress.classList.toggle('hidden');
                setTimeout(resizeCanvas, 300);
            });

            captureButton.addEventListener('click', captureGuide);
            
            resetButton.addEventListener('click', () => {
                guidePanel.style.display = 'none';
                controlsPanel.classList.remove('hidden');
            });
            
            // --- Start the app ---
            populateCameraList();
        });
    </script>
</body>
</html>

